# 3AI项目企业级代码质量与架构现代化指南

## 杨老师，您好！

基于对3AI项目的深度分析，我为您提供企业级的代码质量和架构现代化建议，这些将帮助项目达到行业领先水平。

## 🏗️ 现代化架构模式深度应用

### 1. 微服务架构渐进式演进

#### 1.1 单体到微服务的平滑过渡

```typescript
// src/architecture/ServiceBoundary.ts
/**
 * 服务边界定义 - 为未来微服务拆分做准备
 */
export interface ServiceBoundary {
  name: string;
  domain: string;
  responsibilities: string[];
  dependencies: string[];
  apis: ServiceAPI[];
  events: DomainEvent[];
}

export interface ServiceAPI {
  endpoint: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  purpose: string;
  inputSchema: object;
  outputSchema: object;
}

export interface DomainEvent {
  name: string;
  payload: object;
  triggers: string[];
  consumers: string[];
}

// 用户服务边界定义
export const UserServiceBoundary: ServiceBoundary = {
  name: 'UserService',
  domain: 'User Management',
  responsibilities: [
    '用户注册和认证',
    '用户信息管理',
    '权限控制',
    '用户偏好设置'
  ],
  dependencies: [
    'NotificationService',
    'AuditService'
  ],
  apis: [
    {
      endpoint: '/api/users',
      method: 'POST',
      purpose: '创建新用户',
      inputSchema: {
        type: 'object',
        properties: {
          email: { type: 'string', format: 'email' },
          name: { type: 'string', minLength: 2 },
          password: { type: 'string', minLength: 8 }
        },
        required: ['email', 'name', 'password']
      },
      outputSchema: {
        type: 'object',
        properties: {
          id: { type: 'string' },
          email: { type: 'string' },
          name: { type: 'string' },
          createdAt: { type: 'string', format: 'date-time' }
        }
      }
    }
  ],
  events: [
    {
      name: 'UserCreated',
      payload: {
        userId: 'string',
        email: 'string',
        name: 'string',
        timestamp: 'string'
      },
      triggers: ['用户注册成功'],
      consumers: ['NotificationService', 'AuditService', 'AnalyticsService']
    }
  ]
};
```

#### 1.2 事件驱动架构实现

```typescript
// src/events/EventBus.ts
import { EventEmitter } from 'events';
import { logger } from '../utils/logger';

export interface DomainEvent {
  id: string;
  type: string;
  aggregateId: string;
  aggregateType: string;
  version: number;
  timestamp: Date;
  payload: any;
  metadata?: Record<string, any>;
}

export interface EventHandler<T = any> {
  handle(event: DomainEvent<T>): Promise<void>;
  canHandle(eventType: string): boolean;
  getHandlerName(): string;
}

export class EventBus {
  private emitter: EventEmitter;
  private handlers: Map<string, EventHandler[]>;
  private eventStore: DomainEvent[];
  private retryQueue: Map<string, { event: DomainEvent; attempts: number }>;
  private maxRetries: number = 3;

  constructor() {
    this.emitter = new EventEmitter();
    this.handlers = new Map();
    this.eventStore = [];
    this.retryQueue = new Map();
    this.setupErrorHandling();
  }

  /**
   * 发布领域事件
   */
  async publish(event: DomainEvent): Promise<void> {
    try {
      // 持久化事件
      await this.persistEvent(event);
      
      // 记录事件发布
      logger.info('事件已发布', {
        eventId: event.id,
        eventType: event.type,
        aggregateId: event.aggregateId
      });
      
      // 异步处理事件
      this.emitter.emit(event.type, event);
      
      // 处理事件处理器
      const handlers = this.handlers.get(event.type) || [];
      await this.processHandlers(event, handlers);
      
    } catch (error) {
      logger.error('事件发布失败', {
        eventId: event.id,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * 订阅事件处理器
   */
  subscribe<T>(eventType: string, handler: EventHandler<T>): void {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, []);
    }
    
    this.handlers.get(eventType)!.push(handler);
    
    logger.info('事件处理器已注册', {
      eventType,
      handlerName: handler.getHandlerName()
    });
  }

  /**
   * 处理事件处理器
   */
  private async processHandlers(event: DomainEvent, handlers: EventHandler[]): Promise<void> {
    const promises = handlers.map(async (handler) => {
      try {
        if (handler.canHandle(event.type)) {
          await handler.handle(event);
          logger.debug('事件处理成功', {
            eventId: event.id,
            handlerName: handler.getHandlerName()
          });
        }
      } catch (error) {
        logger.error('事件处理失败', {
          eventId: event.id,
          handlerName: handler.getHandlerName(),
          error: error.message
        });
        
        // 添加到重试队列
        await this.addToRetryQueue(event, handler);
      }
    });
    
    await Promise.allSettled(promises);
  }

  /**
   * 重试机制
   */
  private async addToRetryQueue(event: DomainEvent, handler: EventHandler): Promise<void> {
    const retryKey = `${event.id}_${handler.getHandlerName()}`;
    const retryInfo = this.retryQueue.get(retryKey) || { event, attempts: 0 };
    
    if (retryInfo.attempts < this.maxRetries) {
      retryInfo.attempts++;
      this.retryQueue.set(retryKey, retryInfo);
      
      // 延迟重试
      setTimeout(async () => {
        try {
          await handler.handle(event);
          this.retryQueue.delete(retryKey);
          logger.info('事件重试处理成功', {
            eventId: event.id,
            handlerName: handler.getHandlerName(),
            attempts: retryInfo.attempts
          });
        } catch (error) {
          logger.error('事件重试处理失败', {
            eventId: event.id,
            handlerName: handler.getHandlerName(),
            attempts: retryInfo.attempts,
            error: error.message
          });
          
          if (retryInfo.attempts >= this.maxRetries) {
            await this.handleDeadLetter(event, handler, error);
          } else {
            await this.addToRetryQueue(event, handler);
          }
        }
      }, Math.pow(2, retryInfo.attempts) * 1000); // 指数退避
    } else {
      await this.handleDeadLetter(event, handler, new Error('超过最大重试次数'));
    }
  }

  /**
   * 死信处理
   */
  private async handleDeadLetter(event: DomainEvent, handler: EventHandler, error: Error): Promise<void> {
    logger.error('事件进入死信队列', {
      eventId: event.id,
      handlerName: handler.getHandlerName(),
      error: error.message
    });
    
    // 这里可以将事件发送到死信队列或通知管理员
    // await deadLetterQueue.send(event, handler, error);
  }

  /**
   * 持久化事件
   */
  private async persistEvent(event: DomainEvent): Promise<void> {
    // 在实际应用中，这里应该持久化到数据库
    this.eventStore.push(event);
  }

  /**
   * 设置错误处理
   */
  private setupErrorHandling(): void {
    this.emitter.on('error', (error) => {
      logger.error('EventBus错误', { error: error.message });
    });
  }

  /**
   * 获取事件历史
   */
  getEventHistory(aggregateId: string): DomainEvent[] {
    return this.eventStore.filter(event => event.aggregateId === aggregateId);
  }

  /**
   * 重放事件
   */
  async replayEvents(aggregateId: string, fromVersion?: number): Promise<void> {
    const events = this.getEventHistory(aggregateId)
      .filter(event => !fromVersion || event.version >= fromVersion)
      .sort((a, b) => a.version - b.version);
    
    for (const event of events) {
      await this.publish(event);
    }
  }
}

// 事件处理器示例
export class UserCreatedHandler implements EventHandler {
  constructor(
    private notificationService: any,
    private auditService: any
  ) {}

  async handle(event: DomainEvent): Promise<void> {
    const { userId, email, name } = event.payload;
    
    // 发送欢迎邮件
    await this.notificationService.sendWelcomeEmail(email, name);
    
    // 记录审计日志
    await this.auditService.logUserCreation(userId, {
      timestamp: event.timestamp,
      metadata: event.metadata
    });
  }

  canHandle(eventType: string): boolean {
    return eventType === 'UserCreated';
  }

  getHandlerName(): string {
    return 'UserCreatedHandler';
  }
}
```

### 2. 高级缓存策略与数据一致性

#### 2.1 多层缓存架构

```typescript
// src/cache/CacheManager.ts
import Redis from 'ioredis';
import { LRUCache } from 'lru-cache';
import { logger } from '../utils/logger';

export interface CacheConfig {
  redis: {
    host: string;
    port: number;
    password?: string;
    db: number;
  };
  memory: {
    maxSize: number;
    ttl: number;
  };
  strategies: {
    writeThrough: boolean;
    writeBack: boolean;
    readThrough: boolean;
  };
}

export interface CacheEntry<T> {
  value: T;
  timestamp: number;
  ttl: number;
  version: number;
  tags: string[];
}

export class CacheManager {
  private redis: Redis;
  private memoryCache: LRUCache<string, CacheEntry<any>>;
  private config: CacheConfig;
  private hitStats: Map<string, { hits: number; misses: number }>;

  constructor(config: CacheConfig) {
    this.config = config;
    this.redis = new Redis(config.redis);
    this.memoryCache = new LRUCache({
      max: config.memory.maxSize,
      ttl: config.memory.ttl * 1000
    });
    this.hitStats = new Map();
    this.setupEventHandlers();
  }

  /**
   * 智能缓存获取 - L1(内存) -> L2(Redis) -> 数据源
   */
  async get<T>(key: string, fallback?: () => Promise<T>, ttl?: number): Promise<T | null> {
    const startTime = Date.now();
    
    try {
      // L1: 内存缓存
      const memoryEntry = this.memoryCache.get(key);
      if (memoryEntry && !this.isExpired(memoryEntry)) {
        this.recordHit(key, 'memory');
        logger.debug('缓存命中 (内存)', { key, responseTime: Date.now() - startTime });
        return memoryEntry.value;
      }

      // L2: Redis缓存
      const redisValue = await this.redis.get(key);
      if (redisValue) {
        const entry: CacheEntry<T> = JSON.parse(redisValue);
        if (!this.isExpired(entry)) {
          // 回写到内存缓存
          this.memoryCache.set(key, entry);
          this.recordHit(key, 'redis');
          logger.debug('缓存命中 (Redis)', { key, responseTime: Date.now() - startTime });
          return entry.value;
        }
      }

      // L3: 数据源
      if (fallback) {
        const value = await fallback();
        if (value !== null && value !== undefined) {
          await this.set(key, value, ttl);
          this.recordMiss(key);
          logger.debug('缓存未命中，从数据源获取', { key, responseTime: Date.now() - startTime });
          return value;
        }
      }

      this.recordMiss(key);
      return null;
    } catch (error) {
      logger.error('缓存获取失败', { key, error: error.message });
      if (fallback) {
        return await fallback();
      }
      return null;
    }
  }

  /**
   * 智能缓存设置
   */
  async set<T>(key: string, value: T, ttl?: number, tags?: string[]): Promise<void> {
    const entry: CacheEntry<T> = {
      value,
      timestamp: Date.now(),
      ttl: ttl || 3600,
      version: 1,
      tags: tags || []
    };

    try {
      // 写入内存缓存
      this.memoryCache.set(key, entry);
      
      // 写入Redis缓存
      await this.redis.setex(key, entry.ttl, JSON.stringify(entry));
      
      // 如果有标签，建立标签索引
      if (tags && tags.length > 0) {
        await this.indexTags(key, tags);
      }
      
      logger.debug('缓存已设置', { key, ttl: entry.ttl, tags });
    } catch (error) {
      logger.error('缓存设置失败', { key, error: error.message });
    }
  }

  /**
   * 按标签批量失效
   */
  async invalidateByTags(tags: string[]): Promise<void> {
    try {
      const keys = new Set<string>();
      
      for (const tag of tags) {
        const tagKeys = await this.redis.smembers(`tag:${tag}`);
        tagKeys.forEach(key => keys.add(key));
      }
      
      if (keys.size > 0) {
        const keyArray = Array.from(keys);
        
        // 从内存缓存删除
        keyArray.forEach(key => this.memoryCache.delete(key));
        
        // 从Redis删除
        await this.redis.del(...keyArray);
        
        // 清理标签索引
        for (const tag of tags) {
          await this.redis.del(`tag:${tag}`);
        }
        
        logger.info('按标签批量失效缓存', { tags, keysCount: keys.size });
      }
    } catch (error) {
      logger.error('按标签失效缓存失败', { tags, error: error.message });
    }
  }

  /**
   * 缓存预热
   */
  async warmup(warmupData: Array<{ key: string; loader: () => Promise<any>; ttl?: number; tags?: string[] }>): Promise<void> {
    logger.info('开始缓存预热', { itemsCount: warmupData.length });
    
    const promises = warmupData.map(async ({ key, loader, ttl, tags }) => {
      try {
        const value = await loader();
        await this.set(key, value, ttl, tags);
        logger.debug('缓存预热成功', { key });
      } catch (error) {
        logger.error('缓存预热失败', { key, error: error.message });
      }
    });
    
    await Promise.allSettled(promises);
    logger.info('缓存预热完成');
  }

  /**
   * 缓存统计
   */
  getStats(): Record<string, any> {
    const stats = {
      memory: {
        size: this.memoryCache.size,
        maxSize: this.memoryCache.max
      },
      hitRates: {} as Record<string, number>
    };
    
    this.hitStats.forEach((stat, key) => {
      const total = stat.hits + stat.misses;
      stats.hitRates[key] = total > 0 ? (stat.hits / total) * 100 : 0;
    });
    
    return stats;
  }

  /**
   * 缓存健康检查
   */
  async healthCheck(): Promise<{ status: 'healthy' | 'degraded' | 'unhealthy'; details: any }> {
    try {
      const testKey = 'health_check_' + Date.now();
      const testValue = 'test';
      
      // 测试写入
      await this.set(testKey, testValue, 10);
      
      // 测试读取
      const retrievedValue = await this.get(testKey);
      
      // 清理测试数据
      await this.delete(testKey);
      
      if (retrievedValue === testValue) {
        return {
          status: 'healthy',
          details: {
            redis: 'connected',
            memory: 'operational',
            stats: this.getStats()
          }
        };
      } else {
        return {
          status: 'degraded',
          details: {
            issue: '缓存读写不一致',
            stats: this.getStats()
          }
        };
      }
    } catch (error) {
      return {
        status: 'unhealthy',
        details: {
          error: error.message,
          stats: this.getStats()
        }
      };
    }
  }

  private async indexTags(key: string, tags: string[]): Promise<void> {
    const pipeline = this.redis.pipeline();
    tags.forEach(tag => {
      pipeline.sadd(`tag:${tag}`, key);
    });
    await pipeline.exec();
  }

  private isExpired(entry: CacheEntry<any>): boolean {
    return Date.now() - entry.timestamp > entry.ttl * 1000;
  }

  private recordHit(key: string, source: string): void {
    const statKey = `${key}_${source}`;
    const stat = this.hitStats.get(statKey) || { hits: 0, misses: 0 };
    stat.hits++;
    this.hitStats.set(statKey, stat);
  }

  private recordMiss(key: string): void {
    const stat = this.hitStats.get(key) || { hits: 0, misses: 0 };
    stat.misses++;
    this.hitStats.set(key, stat);
  }

  private setupEventHandlers(): void {
    this.redis.on('error', (error) => {
      logger.error('Redis连接错误', { error: error.message });
    });
    
    this.redis.on('connect', () => {
      logger.info('Redis连接成功');
    });
  }

  async delete(key: string): Promise<void> {
    this.memoryCache.delete(key);
    await this.redis.del(key);
  }

  async clear(): Promise<void> {
    this.memoryCache.clear();
    await this.redis.flushdb();
  }
}
```

### 3. 高级安全防护体系

#### 3.1 多层安全中间件

```typescript
// src/security/SecurityMiddleware.ts
import { Request, Response, NextFunction } from 'express';
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import { body, validationResult } from 'express-validator';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import { logger } from '../utils/logger';

export interface SecurityConfig {
  rateLimit: {
    windowMs: number;
    max: number;
    skipSuccessfulRequests: boolean;
  };
  jwt: {
    secret: string;
    expiresIn: string;
    refreshExpiresIn: string;
  };
  encryption: {
    algorithm: string;
    keyLength: number;
  };
  csrf: {
    enabled: boolean;
    cookieName: string;
  };
}

export class SecurityMiddleware {
  private config: SecurityConfig;
  private suspiciousIPs: Map<string, { attempts: number; lastAttempt: Date }> = new Map();
  private encryptionKey: Buffer;

  constructor(config: SecurityConfig) {
    this.config = config;
    this.encryptionKey = crypto.randomBytes(config.encryption.keyLength);
  }

  /**
   * 基础安全头设置
   */
  basicSecurity() {
    return helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'],
          fontSrc: ["'self'", 'https://fonts.gstatic.com'],
          imgSrc: ["'self'", 'data:', 'https:'],
          scriptSrc: ["'self'"],
          connectSrc: ["'self'"],
          frameSrc: ["'none'"],
          objectSrc: ["'none'"],
          upgradeInsecureRequests: []
        }
      },
      hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
      },
      noSniff: true,
      xssFilter: true,
      referrerPolicy: { policy: 'strict-origin-when-cross-origin' }
    });
  }

  /**
   * 智能速率限制
   */
  intelligentRateLimit() {
    return rateLimit({
      windowMs: this.config.rateLimit.windowMs,
      max: (req: Request) => {
        // 根据用户类型和端点调整限制
        if (req.path.startsWith('/api/auth/')) {
          return 5; // 认证端点更严格
        }
        if (req.headers.authorization) {
          return this.config.rateLimit.max * 2; // 已认证用户更宽松
        }
        return this.config.rateLimit.max;
      },
      skipSuccessfulRequests: this.config.rateLimit.skipSuccessfulRequests,
      keyGenerator: (req: Request) => {
        // 组合IP和用户ID作为限制键
        const ip = this.getClientIP(req);
        const userId = req.user?.id || 'anonymous';
        return `${ip}:${userId}`;
      },
      onLimitReached: (req: Request) => {
        const ip = this.getClientIP(req);
        this.recordSuspiciousActivity(ip, 'rate_limit_exceeded');
        logger.warn('速率限制触发', {
          ip,
          path: req.path,
          userAgent: req.headers['user-agent']
        });
      }
    });
  }

  /**
   * JWT认证中间件
   */
  jwtAuth() {
    return async (req: Request, res: Response, next: NextFunction) => {
      try {
        const token = this.extractToken(req);
        
        if (!token) {
          return res.status(401).json({
            success: false,
            error: {
              code: 'MISSING_TOKEN',
              message: '缺少认证令牌'
            }
          });
        }

        const decoded = jwt.verify(token, this.config.jwt.secret) as any;
        
        // 检查令牌是否在黑名单中
        if (await this.isTokenBlacklisted(token)) {
          return res.status(401).json({
            success: false,
            error: {
              code: 'TOKEN_BLACKLISTED',
              message: '令牌已失效'
            }
          });
        }

        // 检查用户是否仍然有效
        if (!(await this.isUserValid(decoded.userId))) {
          return res.status(401).json({
            success: false,
            error: {
              code: 'USER_INVALID',
              message: '用户账户无效'
            }
          });
        }

        req.user = decoded;
        next();
      } catch (error) {
        if (error.name === 'TokenExpiredError') {
          return res.status(401).json({
            success: false,
            error: {
              code: 'TOKEN_EXPIRED',
              message: '令牌已过期'
            }
          });
        }
        
        logger.error('JWT认证失败', {
          error: error.message,
          ip: this.getClientIP(req)
        });
        
        return res.status(401).json({
          success: false,
          error: {
            code: 'INVALID_TOKEN',
            message: '无效的认证令牌'
          }
        });
      }
    };
  }

  /**
   * 输入验证和清理
   */
  inputValidation(validationRules: any[]) {
    return [
      ...validationRules,
      (req: Request, res: Response, next: NextFunction) => {
        const errors = validationResult(req);
        
        if (!errors.isEmpty()) {
          const sanitizedErrors = errors.array().map(error => ({
            field: error.param,
            message: this.sanitizeErrorMessage(error.msg),
            value: this.sanitizeValue(error.value)
          }));
          
          logger.warn('输入验证失败', {
            ip: this.getClientIP(req),
            path: req.path,
            errors: sanitizedErrors
          });
          
          return res.status(400).json({
            success: false,
            error: {
              code: 'VALIDATION_ERROR',
              message: '输入数据验证失败',
              details: sanitizedErrors
            }
          });
        }
        
        // 清理输入数据
        req.body = this.sanitizeObject(req.body);
        req.query = this.sanitizeObject(req.query);
        
        next();
      }
    ];
  }

  /**
   * SQL注入防护
   */
  sqlInjectionProtection() {
    return (req: Request, res: Response, next: NextFunction) => {
      const suspiciousPatterns = [
        /('|(\-\-)|(;)|(\||\|)|(\*|\*))/i,
        /(union|select|insert|delete|update|drop|create|alter|exec|execute)/i,
        /(script|javascript|vbscript|onload|onerror|onclick)/i
      ];
      
      const checkValue = (value: any): boolean => {
        if (typeof value === 'string') {
          return suspiciousPatterns.some(pattern => pattern.test(value));
        }
        if (typeof value === 'object' && value !== null) {
          return Object.values(value).some(checkValue);
        }
        return false;
      };
      
      if (checkValue(req.body) || checkValue(req.query) || checkValue(req.params)) {
        const ip = this.getClientIP(req);
        this.recordSuspiciousActivity(ip, 'sql_injection_attempt');
        
        logger.error('检测到SQL注入尝试', {
          ip,
          path: req.path,
          userAgent: req.headers['user-agent'],
          body: this.sanitizeObject(req.body),
          query: this.sanitizeObject(req.query)
        });
        
        return res.status(400).json({
          success: false,
          error: {
            code: 'MALICIOUS_INPUT',
            message: '检测到恶意输入'
          }
        });
      }
      
      next();
    };
  }

  /**
   * CSRF保护
   */
  csrfProtection() {
    return (req: Request, res: Response, next: NextFunction) => {
      if (!this.config.csrf.enabled) {
        return next();
      }
      
      if (['GET', 'HEAD', 'OPTIONS'].includes(req.method)) {
        return next();
      }
      
      const token = req.headers['x-csrf-token'] || req.body._csrf;
      const sessionToken = req.session?.csrfToken;
      
      if (!token || !sessionToken || token !== sessionToken) {
        logger.warn('CSRF令牌验证失败', {
          ip: this.getClientIP(req),
          path: req.path
        });
        
        return res.status(403).json({
          success: false,
          error: {
            code: 'CSRF_TOKEN_INVALID',
            message: 'CSRF令牌无效'
          }
        });
      }
      
      next();
    };
  }

  /**
   * 敏感数据加密
   */
  encrypt(data: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.config.encryption.algorithm, this.encryptionKey);
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return iv.toString('hex') + ':' + encrypted;
  }

  /**
   * 敏感数据解密
   */
  decrypt(encryptedData: string): string {
    const parts = encryptedData.split(':');
    const iv = Buffer.from(parts[0], 'hex');
    const encrypted = parts[1];
    const decipher = crypto.createDecipher(this.config.encryption.algorithm, this.encryptionKey);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  }

  private extractToken(req: Request): string | null {
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      return authHeader.substring(7);
    }
    return req.cookies?.token || null;
  }

  private async isTokenBlacklisted(token: string): Promise<boolean> {
    // 实现令牌黑名单检查
    // 可以使用Redis存储黑名单令牌
    return false;
  }

  private async isUserValid(userId: string): Promise<boolean> {
    // 实现用户有效性检查
    // 检查用户是否被禁用、删除等
    return true;
  }

  private getClientIP(req: Request): string {
    return req.ip || 
           req.connection.remoteAddress || 
           req.socket.remoteAddress || 
           (req.connection as any)?.socket?.remoteAddress || 
           'unknown';
  }

  private recordSuspiciousActivity(ip: string, activity: string): void {
    const record = this.suspiciousIPs.get(ip) || { attempts: 0, lastAttempt: new Date() };
    record.attempts++;
    record.lastAttempt = new Date();
    this.suspiciousIPs.set(ip, record);
    
    // 如果可疑活动过多，可以考虑自动封禁
    if (record.attempts > 10) {
      logger.error('检测到高频可疑活动', {
        ip,
        activity,
        attempts: record.attempts
      });
    }
  }

  private sanitizeErrorMessage(message: string): string {
    // 清理错误消息，避免泄露敏感信息
    return message.replace(/[<>"'&]/g, '');
  }

  private sanitizeValue(value: any): any {
    if (typeof value === 'string') {
      return value.replace(/[<>"'&]/g, '').substring(0, 100);
    }
    return '[sanitized]';
  }

  private sanitizeObject(obj: any): any {
    if (typeof obj === 'string') {
      return this.sanitizeValue(obj);
    }
    if (typeof obj === 'object' && obj !== null) {
      const sanitized: any = {};
      Object.keys(obj).forEach(key => {
        sanitized[key] = this.sanitizeObject(obj[key]);
      });
      return sanitized;
    }
    return obj;
  }
}
```

## 🔬 高级测试策略

### 1. 契约测试与API版本管理

```typescript
// src/testing/ContractTesting.ts
import { Pact, Matchers } from '@pact-foundation/pact';
import { logger } from '../utils/logger';

export interface APIContract {
  consumer: string;
  provider: string;
  version: string;
  interactions: ContractInteraction[];
}

export interface ContractInteraction {
  description: string;
  providerState?: string;
  request: {
    method: string;
    path: string;
    headers?: Record<string, string>;
    body?: any;
  };
  response: {
    status: number;
    headers?: Record<string, string>;
    body?: any;
  };
}

export class ContractTestManager {
  private pact: Pact;
  private contracts: Map<string, APIContract> = new Map();

  constructor(consumerName: string, providerName: string) {
    this.pact = new Pact({
      consumer: consumerName,
      provider: providerName,
      port: 1234,
      log: './logs/pact.log',
      dir: './pacts',
      logLevel: 'INFO'
    });
  }

  /**
   * 定义API契约
   */
  defineContract(contractId: string, contract: APIContract): void {
    this.contracts.set(contractId, contract);
    logger.info('API契约已定义', { contractId, consumer: contract.consumer, provider: contract.provider });
  }

  /**
   * 执行契约测试
   */
  async runContractTests(contractId: string): Promise<boolean> {
    const contract = this.contracts.get(contractId);
    if (!contract) {
      throw new Error(`契约不存在: ${contractId}`);
    }

    try {
      await this.pact.setup();

      for (const interaction of contract.interactions) {
        await this.pact.addInteraction({
          description: interaction.description,
          providerState: interaction.providerState,
          uponReceiving: interaction.description,
          withRequest: {
            method: interaction.request.method,
            path: interaction.request.path,
            headers: interaction.request.headers,
            body: interaction.request.body
          },
          willRespondWith: {
            status: interaction.response.status,
            headers: interaction.response.headers,
            body: interaction.response.body
          }
        });
      }

      // 执行实际的API调用测试
      await this.executeAPITests(contract);

      await this.pact.verify();
      await this.pact.finalize();

      logger.info('契约测试通过', { contractId });
      return true;
    } catch (error) {
      logger.error('契约测试失败', { contractId, error: error.message });
      return false;
    }
  }

  /**
   * 验证API向后兼容性
   */
  async verifyBackwardCompatibility(oldVersion: string, newVersion: string): Promise<{
    compatible: boolean;
    breakingChanges: string[];
    warnings: string[];
  }> {
    const result = {
      compatible: true,
      breakingChanges: [] as string[],
      warnings: [] as string[]
    };

    // 这里实现API版本比较逻辑
    // 检查字段删除、类型变更、必填字段添加等
    
    return result;
  }

  private async executeAPITests(contract: APIContract): Promise<void> {
    // 实现实际的API调用测试
    // 这里应该调用真实的API端点进行测试
  }
}
```

### 2. 性能测试自动化

```typescript
// src/testing/PerformanceTesting.ts
import autocannon from 'autocannon';
import { logger } from '../utils/logger';

export interface PerformanceTestConfig {
  url: string;
  connections: number;
  duration: number;
  pipelining: number;
  headers?: Record<string, string>;
  body?: string;
  method?: string;
}

export interface PerformanceResult {
  url: string;
  timestamp: Date;
  duration: number;
  requests: {
    total: number;
    average: number;
    min: number;
    max: number;
    p50: number;
    p90: number;
    p95: number;
    p99: number;
  };
  latency: {
    average: number;
    min: number;
    max: number;
    p50: number;
    p90: number;
    p95: number;
    p99: number;
  };
  throughput: {
    average: number;
    min: number;
    max: number;
  };
  errors: number;
  timeouts: number;
}

export class PerformanceTestSuite {
  private baselineResults: Map<string, PerformanceResult> = new Map();
  private thresholds: Map<string, PerformanceThresholds> = new Map();

  /**
   * 执行性能测试
   */
  async runPerformanceTest(testName: string, config: PerformanceTestConfig): Promise<PerformanceResult> {
    logger.info('开始性能测试', { testName, config });

    try {
      const result = await autocannon({
        url: config.url,
        connections: config.connections,
        duration: config.duration,
        pipelining: config.pipelining,
        headers: config.headers,
        body: config.body,
        method: config.method || 'GET'
      });

      const performanceResult: PerformanceResult = {
        url: config.url,
        timestamp: new Date(),
        duration: config.duration,
        requests: {
          total: result.requests.total,
          average: result.requests.average,
          min: result.requests.min,
          max: result.requests.max,
          p50: result.requests.p50,
          p90: result.requests.p90,
          p95: result.requests.p95,
          p99: result.requests.p99
        },
        latency: {
          average: result.latency.average,
          min: result.latency.min,
          max: result.latency.max,
          p50: result.latency.p50,
          p90: result.latency.p90,
          p95: result.latency.p95,
          p99: result.latency.p99
        },
        throughput: {
          average: result.throughput.average,
          min: result.throughput.min,
          max: result.throughput.max
        },
        errors: result.errors,
        timeouts: result.timeouts
      };

      // 与基线对比
      await this.compareWithBaseline(testName, performanceResult);

      logger.info('性能测试完成', {
        testName,
        requestsPerSecond: performanceResult.requests.average,
        averageLatency: performanceResult.latency.average,
        errors: performanceResult.errors
      });

      return performanceResult;
    } catch (error) {
      logger.error('性能测试失败', { testName, error: error.message });
      throw error;
    }
  }

  /**
   * 设置性能基线
   */
  setBaseline(testName: string, result: PerformanceResult): void {
    this.baselineResults.set(testName, result);
    logger.info('性能基线已设置', { testName });
  }

  /**
   * 设置性能阈值
   */
  setThresholds(testName: string, thresholds: PerformanceThresholds): void {
    this.thresholds.set(testName, thresholds);
    logger.info('性能阈值已设置', { testName, thresholds });
  }

  /**
   * 与基线对比
   */
  private async compareWithBaseline(testName: string, currentResult: PerformanceResult): Promise<void> {
    const baseline = this.baselineResults.get(testName);
    const thresholds = this.thresholds.get(testName);

    if (!baseline) {
      logger.info('未找到性能基线，将当前结果设为基线', { testName });
      this.setBaseline(testName, currentResult);
      return;
    }

    const comparison = {
      requestsPerSecondChange: ((currentResult.requests.average - baseline.requests.average) / baseline.requests.average) * 100,
      latencyChange: ((currentResult.latency.average - baseline.latency.average) / baseline.latency.average) * 100,
      errorRateChange: currentResult.errors - baseline.errors
    };

    logger.info('性能对比结果', {
      testName,
      comparison,
      current: {
        rps: currentResult.requests.average,
        latency: currentResult.latency.average,
        errors: currentResult.errors
      },
      baseline: {
        rps: baseline.requests.average,
        latency: baseline.latency.average,
        errors: baseline.errors
      }
    });

    // 检查是否超过阈值
    if (thresholds) {
      const violations = [];
      
      if (comparison.requestsPerSecondChange < -thresholds.maxRpsDecrease) {
        violations.push(`RPS下降超过阈值: ${comparison.requestsPerSecondChange.toFixed(2)}%`);
      }
      
      if (comparison.latencyChange > thresholds.maxLatencyIncrease) {
        violations.push(`延迟增加超过阈值: ${comparison.latencyChange.toFixed(2)}%`);
      }
      
      if (currentResult.errors > thresholds.maxErrors) {
        violations.push(`错误数超过阈值: ${currentResult.errors}`);
      }

      if (violations.length > 0) {
        logger.error('性能测试未通过阈值检查', { testName, violations });
        throw new Error(`性能回归检测: ${violations.join(', ')}`);
      }
    }
  }

  /**
   * 生成性能报告
   */
  generateReport(results: Map<string, PerformanceResult[]>): string {
    let report = '# 性能测试报告\n\n';
    report += `生成时间: ${new Date().toISOString()}\n\n`;

    results.forEach((testResults, testName) => {
      report += `## ${testName}\n\n`;
      
      if (testResults.length > 0) {
        const latest = testResults[testResults.length - 1];
        report += `- **最新测试时间**: ${latest.timestamp.toISOString()}\n`;
        report += `- **平均RPS**: ${latest.requests.average.toFixed(2)}\n`;
        report += `- **平均延迟**: ${latest.latency.average.toFixed(2)}ms\n`;
        report += `- **P95延迟**: ${latest.latency.p95.toFixed(2)}ms\n`;
        report += `- **错误数**: ${latest.errors}\n`;
        report += `- **超时数**: ${latest.timeouts}\n\n`;
        
        // 趋势分析
        if (testResults.length > 1) {
          const previous = testResults[testResults.length - 2];
          const rpsChange = ((latest.requests.average - previous.requests.average) / previous.requests.average) * 100;
          const latencyChange = ((latest.latency.average - previous.latency.average) / previous.latency.average) * 100;
          
          report += `### 趋势分析\n`;
          report += `- RPS变化: ${rpsChange > 0 ? '+' : ''}${rpsChange.toFixed(2)}%\n`;
          report += `- 延迟变化: ${latencyChange > 0 ? '+' : ''}${latencyChange.toFixed(2)}%\n\n`;
        }
      }
    });

    return report;
  }
}

interface PerformanceThresholds {
  maxRpsDecrease: number; // 最大RPS下降百分比
  maxLatencyIncrease: number; // 最大延迟增加百分比
  maxErrors: number; // 最大错误数
}
```

## 📊 智能监控与可观测性

### 1. 分布式追踪系统

```typescript
// src/monitoring/DistributedTracing.ts
import { trace, context, SpanStatusCode, SpanKind } from '@opentelemetry/api';
import { NodeSDK } from '@opentelemetry/sdk-node';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { JaegerExporter } from '@opentelemetry/exporter-jaeger';
import { logger } from '../utils/logger';

export interface TraceConfig {
  serviceName: string;
  serviceVersion: string;
  jaegerEndpoint: string;
  samplingRate: number;
}

export class DistributedTracingManager {
  private sdk: NodeSDK;
  private tracer: any;
  private config: TraceConfig;

  constructor(config: TraceConfig) {
    this.config = config;
    this.initializeTracing();
  }

  private initializeTracing(): void {
    const jaegerExporter = new JaegerExporter({
      endpoint: this.config.jaegerEndpoint
    });

    this.sdk = new NodeSDK({
      resource: new Resource({
        [SemanticResourceAttributes.SERVICE_NAME]: this.config.serviceName,
        [SemanticResourceAttributes.SERVICE_VERSION]: this.config.serviceVersion
      }),
      traceExporter: jaegerExporter,
      samplingRate: this.config.samplingRate
    });

    this.sdk.start();
    this.tracer = trace.getTracer(this.config.serviceName, this.config.serviceVersion);
    
    logger.info('分布式追踪已初始化', {
      serviceName: this.config.serviceName,
      jaegerEndpoint: this.config.jaegerEndpoint
    });
  }

  /**
   * 创建追踪span
   */
  createSpan(name: string, options?: {
    kind?: SpanKind;
    attributes?: Record<string, any>;
    parent?: any;
  }) {
    const span = this.tracer.startSpan(name, {
      kind: options?.kind || SpanKind.INTERNAL,
      attributes: options?.attributes,
      parent: options?.parent
    });

    return {
      span,
      setStatus: (code: SpanStatusCode, message?: string) => {
        span.setStatus({ code, message });
      },
      setAttribute: (key: string, value: any) => {
        span.setAttribute(key, value);
      },
      addEvent: (name: string, attributes?: Record<string, any>) => {
        span.addEvent(name, attributes);
      },
      end: () => {
        span.end();
      }
    };
  }

  /**
   * HTTP请求追踪中间件
   */
  httpTracingMiddleware() {
    return (req: any, res: any, next: any) => {
      const spanName = `${req.method} ${req.route?.path || req.path}`;
      const span = this.createSpan(spanName, {
        kind: SpanKind.SERVER,
        attributes: {
          'http.method': req.method,
          'http.url': req.url,
          'http.route': req.route?.path,
          'http.user_agent': req.headers['user-agent'],
          'user.id': req.user?.id
        }
      });

      // 将span添加到请求上下文
      req.span = span;

      // 监听响应完成
      res.on('finish', () => {
        span.setAttribute('http.status_code', res.statusCode);
        span.setAttribute('http.response_size', res.get('content-length') || 0);
        
        if (res.statusCode >= 400) {
          span.setStatus(SpanStatusCode.ERROR, `HTTP ${res.statusCode}`);
        } else {
          span.setStatus(SpanStatusCode.OK);
        }
        
        span.end();
      });

      next();
    };
  }

  /**
   * 数据库查询追踪
   */
  traceDatabase<T>(operation: string, query: string, executor: () => Promise<T>): Promise<T> {
    const span = this.createSpan(`db.${operation}`, {
      kind: SpanKind.CLIENT,
      attributes: {
        'db.system': 'postgresql', // 或其他数据库类型
        'db.operation': operation,
        'db.statement': query
      }
    });

    return context.with(trace.setSpan(context.active(), span.span), async () => {
      try {
        const result = await executor();
        span.setStatus(SpanStatusCode.OK);
        return result;
      } catch (error) {
        span.setStatus(SpanStatusCode.ERROR, error.message);
        span.setAttribute('error', true);
        span.setAttribute('error.message', error.message);
        throw error;
      } finally {
        span.end();
      }
    });
  }

  /**
   * 外部API调用追踪
   */
  traceExternalAPI<T>(serviceName: string, endpoint: string, executor: () => Promise<T>): Promise<T> {
    const span = this.createSpan(`external.${serviceName}`, {
      kind: SpanKind.CLIENT,
      attributes: {
        'http.url': endpoint,
        'service.name': serviceName
      }
    });

    return context.with(trace.setSpan(context.active(), span.span), async () => {
      try {
        const startTime = Date.now();
        const result = await executor();
        const duration = Date.now() - startTime;
        
        span.setAttribute('http.duration', duration);
        span.setStatus(SpanStatusCode.OK);
        return result;
      } catch (error) {
        span.setStatus(SpanStatusCode.ERROR, error.message);
        span.setAttribute('error', true);
        span.setAttribute('error.message', error.message);
        throw error;
      } finally {
        span.end();
      }
    });
  }

  /**
   * 业务逻辑追踪装饰器
   */
  trace(operationName?: string) {
    return (target: any, propertyName: string, descriptor: PropertyDescriptor) => {
      const method = descriptor.value;
      const spanName = operationName || `${target.constructor.name}.${propertyName}`;

      descriptor.value = async function (...args: any[]) {
        const span = this.tracingManager.createSpan(spanName, {
          attributes: {
            'operation.name': spanName,
            'operation.args_count': args.length
          }
        });

        return context.with(trace.setSpan(context.active(), span.span), async () => {
          try {
            const result = await method.apply(this, args);
            span.setStatus(SpanStatusCode.OK);
            return result;
          } catch (error) {
            span.setStatus(SpanStatusCode.ERROR, error.message);
            span.setAttribute('error', true);
            span.setAttribute('error.message', error.message);
            throw error;
          } finally {
            span.end();
          }
        });
      };

      return descriptor;
    };
  }

  /**
   * 获取当前追踪上下文
   */
  getCurrentSpan() {
    return trace.getActiveSpan();
  }

  /**
   * 关闭追踪系统
   */
  async shutdown(): Promise<void> {
    await this.sdk.shutdown();
    logger.info('分布式追踪已关闭');
  }
}
```

### 2. 智能告警系统

```typescript
// src/monitoring/AlertingSystem.ts
import { logger } from '../utils/logger';

export interface AlertRule {
  id: string;
  name: string;
  description: string;
  metric: string;
  condition: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';
  threshold: number;
  duration: number; // 持续时间（秒）
  severity: 'low' | 'medium' | 'high' | 'critical';
  channels: AlertChannel[];
  enabled: boolean;
  tags: string[];
}

export interface AlertChannel {
  type: 'email' | 'slack' | 'webhook' | 'sms';
  config: Record<string, any>;
}

export interface Alert {
  id: string;
  ruleId: string;
  metric: string;
  value: number;
  threshold: number;
  severity: string;
  message: string;
  timestamp: Date;
  resolved: boolean;
  resolvedAt?: Date;
}

export class IntelligentAlertingSystem {
  private rules: Map<string, AlertRule> = new Map();
  private activeAlerts: Map<string, Alert> = new Map();
  private metricHistory: Map<string, Array<{ value: number; timestamp: Date }>> = new Map();
  private channels: Map<string, AlertChannel> = new Map();
  private suppressionRules: Map<string, Date> = new Map();

  /**
   * 添加告警规则
   */
  addRule(rule: AlertRule): void {
    this.rules.set(rule.id, rule);
    logger.info('告警规则已添加', { ruleId: rule.id, name: rule.name });
  }

  /**
   * 检查指标并触发告警
   */
  async checkMetric(metric: string, value: number): Promise<void> {
    // 记录指标历史
    this.recordMetric(metric, value);

    // 检查所有相关规则
    const relevantRules = Array.from(this.rules.values())
      .filter(rule => rule.enabled && rule.metric === metric);

    for (const rule of relevantRules) {
      await this.evaluateRule(rule, value);
    }
  }

  /**
   * 评估告警规则
   */
  private async evaluateRule(rule: AlertRule, currentValue: number): Promise<void> {
    const isTriggered = this.evaluateCondition(rule.condition, currentValue, rule.threshold);
    const alertKey = `${rule.id}_${rule.metric}`;
    const existingAlert = this.activeAlerts.get(alertKey);

    if (isTriggered) {
      if (!existingAlert) {
        // 检查是否满足持续时间要求
        if (await this.checkDuration(rule, currentValue)) {
          await this.triggerAlert(rule, currentValue);
        }
      } else {
        // 更新现有告警
        existingAlert.value = currentValue;
        existingAlert.timestamp = new Date();
      }
    } else if (existingAlert && !existingAlert.resolved) {
      // 解决告警
      await this.resolveAlert(existingAlert);
    }
  }

  /**
   * 触发告警
   */
  private async triggerAlert(rule: AlertRule, value: number): Promise<void> {
    const alertId = `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const alert: Alert = {
      id: alertId,
      ruleId: rule.id,
      metric: rule.metric,
      value,
      threshold: rule.threshold,
      severity: rule.severity,
      message: this.generateAlertMessage(rule, value),
      timestamp: new Date(),
      resolved: false
    };

    const alertKey = `${rule.id}_${rule.metric}`;
    this.activeAlerts.set(alertKey, alert);

    // 检查抑制规则
    if (this.isAlertSuppressed(rule)) {
      logger.info('告警被抑制', { alertId, ruleId: rule.id });
      return;
    }

    // 发送告警通知
    await this.sendAlertNotifications(alert, rule);

    logger.error('告警已触发', {
      alertId,
      ruleId: rule.id,
      metric: rule.metric,
      value,
      threshold: rule.threshold,
      severity: rule.severity
    });
  }

  /**
   * 解决告警
   */
  private async resolveAlert(alert: Alert): Promise<void> {
    alert.resolved = true;
    alert.resolvedAt = new Date();

    const rule = this.rules.get(alert.ruleId);
    if (rule) {
      await this.sendResolutionNotifications(alert, rule);
    }

    logger.info('告警已解决', {
      alertId: alert.id,
      ruleId: alert.ruleId,
      duration: alert.resolvedAt.getTime() - alert.timestamp.getTime()
    });
  }

  /**
   * 发送告警通知
   */
  private async sendAlertNotifications(alert: Alert, rule: AlertRule): Promise<void> {
    const notifications = rule.channels.map(async (channel) => {
      try {
        await this.sendNotification(channel, alert, rule);
      } catch (error) {
        logger.error('告警通知发送失败', {
          alertId: alert.id,
          channelType: channel.type,
          error: error.message
        });
      }
    });

    await Promise.allSettled(notifications);
  }

  /**
   * 发送通知
   */
  private async sendNotification(channel: AlertChannel, alert: Alert, rule: AlertRule): Promise<void> {
    switch (channel.type) {
      case 'email':
        await this.sendEmailNotification(channel, alert, rule);
        break;
      case 'slack':
        await this.sendSlackNotification(channel, alert, rule);
        break;
      case 'webhook':
        await this.sendWebhookNotification(channel, alert, rule);
        break;
      case 'sms':
        await this.sendSMSNotification(channel, alert, rule);
        break;
    }
  }

  private async sendEmailNotification(channel: AlertChannel, alert: Alert, rule: AlertRule): Promise<void> {
    // 实现邮件通知
    logger.info('邮件告警通知已发送', { alertId: alert.id, to: channel.config.to });
  }

  private async sendSlackNotification(channel: AlertChannel, alert: Alert, rule: AlertRule): Promise<void> {
    // 实现Slack通知
    logger.info('Slack告警通知已发送', { alertId: alert.id, channel: channel.config.channel });
  }

  private async sendWebhookNotification(channel: AlertChannel, alert: Alert, rule: AlertRule): Promise<void> {
    // 实现Webhook通知
    logger.info('Webhook告警通知已发送', { alertId: alert.id, url: channel.config.url });
  }

  private async sendSMSNotification(channel: AlertChannel, alert: Alert, rule: AlertRule): Promise<void> {
    // 实现SMS通知
    logger.info('SMS告警通知已发送', { alertId: alert.id, phone: channel.config.phone });
  }

  private evaluateCondition(condition: string, value: number, threshold: number): boolean {
    switch (condition) {
      case 'gt': return value > threshold;
      case 'gte': return value >= threshold;
      case 'lt': return value < threshold;
      case 'lte': return value <= threshold;
      case 'eq': return value === threshold;
      default: return false;
    }
  }

  private async checkDuration(rule: AlertRule, value: number): Promise<boolean> {
    const history = this.metricHistory.get(rule.metric) || [];
    const cutoffTime = new Date(Date.now() - rule.duration * 1000);
    
    const recentValues = history.filter(entry => entry.timestamp >= cutoffTime);
    return recentValues.every(entry => 
      this.evaluateCondition(rule.condition, entry.value, rule.threshold)
    );
  }

  private recordMetric(metric: string, value: number): void {
    if (!this.metricHistory.has(metric)) {
      this.metricHistory.set(metric, []);
    }
    
    const history = this.metricHistory.get(metric)!;
    history.push({ value, timestamp: new Date() });
    
    // 保留最近1小时的数据
    const cutoffTime = new Date(Date.now() - 3600000);
    this.metricHistory.set(metric, history.filter(entry => entry.timestamp >= cutoffTime));
  }

  private generateAlertMessage(rule: AlertRule, value: number): string {
    return `告警: ${rule.name} - ${rule.metric} 当前值 ${value} ${rule.condition} 阈值 ${rule.threshold}`;
  }

  private isAlertSuppressed(rule: AlertRule): boolean {
    const suppressionKey = `${rule.id}_${rule.metric}`;
    const suppressedUntil = this.suppressionRules.get(suppressionKey);
    return suppressedUntil ? new Date() < suppressedUntil : false;
  }

  /**
   * 抑制告警
   */
  suppressAlert(ruleId: string, metric: string, duration: number): void {
    const suppressionKey = `${ruleId}_${metric}`;
    const suppressedUntil = new Date(Date.now() + duration * 1000);
    this.suppressionRules.set(suppressionKey, suppressedUntil);
    logger.info('告警已抑制', { ruleId, metric, duration });
  }

  /**
   * 获取活跃告警
   */
  getActiveAlerts(): Alert[] {
    return Array.from(this.activeAlerts.values()).filter(alert => !alert.resolved);
  }

  /**
   * 获取告警统计
   */
  getAlertStats(): {
    total: number;
    bySeverity: Record<string, number>;
    byMetric: Record<string, number>;
    resolved: number;
  } {
    const allAlerts = Array.from(this.activeAlerts.values());
    
    return {
      total: allAlerts.length,
      bySeverity: this.groupBy(allAlerts, 'severity'),
      byMetric: this.groupBy(allAlerts, 'metric'),
      resolved: allAlerts.filter(alert => alert.resolved).length
    };
  }

  private groupBy(items: any[], key: string): Record<string, number> {
    return items.reduce((acc, item) => {
      const value = item[key];
      acc[value] = (acc[value] || 0) + 1;
      return acc;
    }, {});
  }

  private async sendResolutionNotifications(alert: Alert, rule: AlertRule): Promise<void> {
    // 实现告警解决通知
    logger.info('告警解决通知已发送', { alertId: alert.id });
  }
}
```

## 🚀 实施优先级与路线图

### 第一阶段：基础架构现代化（1-2周）

#### 立即实施（本周）
1. **事件驱动架构基础**
   - 实现 `EventBus` 类
   - 创建基础事件处理器
   - 集成到现有业务逻辑

2. **多层缓存系统**
   - 部署 `CacheManager`
   - 配置Redis连接
   - 实现缓存预热策略

#### 下周目标
1. **安全中间件升级**
   - 部署 `SecurityMiddleware`
   - 配置智能速率限制
   - 实现输入验证和清理

2. **分布式追踪**
   - 集成OpenTelemetry
   - 配置Jaeger
   - 添加关键业务流程追踪

### 第二阶段：测试与监控完善（3-4周）

#### 第3周：高级测试策略
1. **契约测试实施**
   - 定义API契约
   - 实现契约测试套件
   - 集成到CI/CD流程

2. **性能测试自动化**
   - 部署性能测试套件
   - 设置性能基线
   - 配置性能回归检测

#### 第4周：智能监控
1. **告警系统部署**
   - 配置告警规则
   - 集成通知渠道
   - 实现告警抑制逻辑

2. **可观测性完善**
   - 完善分布式追踪
   - 添加业务指标监控
   - 实现健康检查端点

### 第三阶段：微服务准备（5-6周）

#### 服务边界定义
1. **领域建模**
   - 识别业务边界
   - 定义服务接口
   - 规划数据迁移策略

2. **API版本管理**
   - 实现API版本控制
   - 配置向后兼容性检查
   - 准备渐进式迁移

## 📈 预期收益与成功指标

### 技术收益
- **性能提升**: 响应时间减少40-60%
- **可靠性增强**: 系统可用性达到99.9%+
- **安全加固**: 安全漏洞减少90%+
- **可维护性**: 代码复杂度降低50%

### 业务收益
- **开发效率**: 新功能交付速度提升50%
- **问题解决**: 故障定位时间减少70%
- **用户体验**: 页面加载速度提升60%
- **运维成本**: 人工干预减少80%

### 关键成功指标
1. **代码质量指标**
   - 代码覆盖率 > 85%
   - 圈复杂度 < 10
   - 技术债务 < 5%

2. **性能指标**
   - API响应时间 < 200ms (P95)
   - 缓存命中率 > 90%
   - 数据库查询时间 < 50ms

3. **可靠性指标**
   - 系统可用性 > 99.9%
   - 错误率 < 0.1%
   - 恢复时间 < 5分钟

## 🎯 下一步行动建议

### 立即开始（今天）
1. **创建开发分支**: `feature/enterprise-architecture`
2. **安装依赖包**: OpenTelemetry, Redis, 安全中间件
3. **配置开发环境**: Jaeger, Redis服务

### 本周完成
1. **实现事件总线**: 核心EventBus类和基础事件处理
2. **部署缓存系统**: 多层缓存架构和预热策略
3. **安全中间件**: 基础安全防护和输入验证

### 本月目标
1. **完整监控体系**: 分布式追踪和智能告警
2. **测试自动化**: 契约测试和性能测试
3. **文档完善**: API文档和运维手册

## 💡 专家建议

### 对杨老师的特别建议
1. **渐进式实施**: 不要一次性改动过多，确保系统稳定性
2. **团队培训**: 安排团队学习新技术和最佳实践
3. **监控先行**: 在重构前先建立完善的监控体系
4. **备份策略**: 确保有完整的回滚方案

### 风险控制
1. **功能开关**: 使用特性开关控制新功能发布
2. **灰度发布**: 逐步推广新架构到生产环境
3. **性能基线**: 建立性能基线，监控回归
4. **应急预案**: 准备快速回滚和故障恢复方案

### 长期愿景
这套企业级架构将为3AI项目提供：
- **可扩展性**: 支持业务快速增长
- **可维护性**: 降低长期维护成本
- **可观测性**: 全面的系统洞察能力
- **安全性**: 企业级安全防护
- **性能**: 高性能和高可用性

---

**杨老师，这份企业级现代化指南将帮助3AI项目达到行业领先水平。建议从事件驱动架构和缓存系统开始实施，逐步完善整个技术栈。我将持续提供技术支持，确保实施过程顺利进行。**